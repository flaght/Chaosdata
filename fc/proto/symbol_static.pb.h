// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: symbol_static.proto

#ifndef PROTOBUF_symbol_5fstatic_2eproto__INCLUDED
#define PROTOBUF_symbol_5fstatic_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace chaos_data {
class SymbolStatic;
class SymbolStaticDefaultTypeInternal;
extern SymbolStaticDefaultTypeInternal _SymbolStatic_default_instance_;
class SymbolStatic_BoundMessage;
class SymbolStatic_BoundMessageDefaultTypeInternal;
extern SymbolStatic_BoundMessageDefaultTypeInternal _SymbolStatic_BoundMessage_default_instance_;
class SymbolStatic_CNVTMessage;
class SymbolStatic_CNVTMessageDefaultTypeInternal;
extern SymbolStatic_CNVTMessageDefaultTypeInternal _SymbolStatic_CNVTMessage_default_instance_;
class SymbolStatic_EquityMessage;
class SymbolStatic_EquityMessageDefaultTypeInternal;
extern SymbolStatic_EquityMessageDefaultTypeInternal _SymbolStatic_EquityMessage_default_instance_;
class SymbolStatic_FundMessage;
class SymbolStatic_FundMessageDefaultTypeInternal;
extern SymbolStatic_FundMessageDefaultTypeInternal _SymbolStatic_FundMessage_default_instance_;
class SymbolStatic_FutureMessage;
class SymbolStatic_FutureMessageDefaultTypeInternal;
extern SymbolStatic_FutureMessageDefaultTypeInternal _SymbolStatic_FutureMessage_default_instance_;
class SymbolStatic_SpecMessage;
class SymbolStatic_SpecMessageDefaultTypeInternal;
extern SymbolStatic_SpecMessageDefaultTypeInternal _SymbolStatic_SpecMessage_default_instance_;
class SymbolStatic_TruestMessage;
class SymbolStatic_TruestMessageDefaultTypeInternal;
extern SymbolStatic_TruestMessageDefaultTypeInternal _SymbolStatic_TruestMessage_default_instance_;
class SymbolStatic_WarranMessage;
class SymbolStatic_WarranMessageDefaultTypeInternal;
extern SymbolStatic_WarranMessageDefaultTypeInternal _SymbolStatic_WarranMessage_default_instance_;
}  // namespace chaos_data

namespace chaos_data {

namespace protobuf_symbol_5fstatic_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_symbol_5fstatic_2eproto

enum SymbolStatic_SYMBOL_TYPE {
  SymbolStatic_SYMBOL_TYPE_INDEX = 0,
  SymbolStatic_SYMBOL_TYPE_STOCK = 1,
  SymbolStatic_SYMBOL_TYPE_FUND = 2,
  SymbolStatic_SYMBOL_TYPE_BOND = 3,
  SymbolStatic_SYMBOL_TYPE_OTHER_STOCK = 4,
  SymbolStatic_SYMBOL_TYPE_OPTION = 5,
  SymbolStatic_SYMBOL_TYPE_EXCHANGE = 6,
  SymbolStatic_SYMBOL_TYPE_FUTURE = 7,
  SymbolStatic_SYMBOL_TYPE_FTR_IDX = 8,
  SymbolStatic_SYMBOL_TYPE_RGZ = 9,
  SymbolStatic_SYMBOL_TYPE_ETF = 10,
  SymbolStatic_SYMBOL_TYPE_LOF = 11,
  SymbolStatic_SYMBOL_TYPE_COV_BOND = 12,
  SymbolStatic_SYMBOL_TYPE_TRUST = 13,
  SymbolStatic_SYMBOL_TYPE_WARRANT = 14,
  SymbolStatic_SYMBOL_TYPE_REPO = 15,
  SymbolStatic_SYMBOL_TYPE_COMM = 16
};
bool SymbolStatic_SYMBOL_TYPE_IsValid(int value);
const SymbolStatic_SYMBOL_TYPE SymbolStatic_SYMBOL_TYPE_SYMBOL_TYPE_MIN = SymbolStatic_SYMBOL_TYPE_INDEX;
const SymbolStatic_SYMBOL_TYPE SymbolStatic_SYMBOL_TYPE_SYMBOL_TYPE_MAX = SymbolStatic_SYMBOL_TYPE_COMM;
const int SymbolStatic_SYMBOL_TYPE_SYMBOL_TYPE_ARRAYSIZE = SymbolStatic_SYMBOL_TYPE_SYMBOL_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SymbolStatic_SYMBOL_TYPE_descriptor();
inline const ::std::string& SymbolStatic_SYMBOL_TYPE_Name(SymbolStatic_SYMBOL_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SymbolStatic_SYMBOL_TYPE_descriptor(), value);
}
inline bool SymbolStatic_SYMBOL_TYPE_Parse(
    const ::std::string& name, SymbolStatic_SYMBOL_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SymbolStatic_SYMBOL_TYPE>(
    SymbolStatic_SYMBOL_TYPE_descriptor(), name, value);
}
enum SymbolStatic_SYMBOL_SUBTYPE {
  SymbolStatic_SYMBOL_SUBTYPE_NILTYPE = 0,
  SymbolStatic_SYMBOL_SUBTYPE_ASHARE = 65,
  SymbolStatic_SYMBOL_SUBTYPE_BSHARE = 66,
  SymbolStatic_SYMBOL_SUBTYPE_GOV_BOND = 71,
  SymbolStatic_SYMBOL_SUBTYPE_ENT_BOND = 79,
  SymbolStatic_SYMBOL_SUBTYPE_FIN_BOND = 70
};
bool SymbolStatic_SYMBOL_SUBTYPE_IsValid(int value);
const SymbolStatic_SYMBOL_SUBTYPE SymbolStatic_SYMBOL_SUBTYPE_SYMBOL_SUBTYPE_MIN = SymbolStatic_SYMBOL_SUBTYPE_NILTYPE;
const SymbolStatic_SYMBOL_SUBTYPE SymbolStatic_SYMBOL_SUBTYPE_SYMBOL_SUBTYPE_MAX = SymbolStatic_SYMBOL_SUBTYPE_ENT_BOND;
const int SymbolStatic_SYMBOL_SUBTYPE_SYMBOL_SUBTYPE_ARRAYSIZE = SymbolStatic_SYMBOL_SUBTYPE_SYMBOL_SUBTYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SymbolStatic_SYMBOL_SUBTYPE_descriptor();
inline const ::std::string& SymbolStatic_SYMBOL_SUBTYPE_Name(SymbolStatic_SYMBOL_SUBTYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SymbolStatic_SYMBOL_SUBTYPE_descriptor(), value);
}
inline bool SymbolStatic_SYMBOL_SUBTYPE_Parse(
    const ::std::string& name, SymbolStatic_SYMBOL_SUBTYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SymbolStatic_SYMBOL_SUBTYPE>(
    SymbolStatic_SYMBOL_SUBTYPE_descriptor(), name, value);
}
enum SymbolStatic_SYMBOL_SP {
  SymbolStatic_SYMBOL_SP_NULLSP = 0,
  SymbolStatic_SYMBOL_SP_NSP = 78,
  SymbolStatic_SYMBOL_SP_SSP = 83,
  SymbolStatic_SYMBOL_SP_PSP = 80,
  SymbolStatic_SYMBOL_SP_TSP = 84,
  SymbolStatic_SYMBOL_SP_LSP = 76,
  SymbolStatic_SYMBOL_SP_OSP = 79,
  SymbolStatic_SYMBOL_SP_FSP = 70,
  SymbolStatic_SYMBOL_SP_ESP = 69,
  SymbolStatic_SYMBOL_SP_ZSP = 90
};
bool SymbolStatic_SYMBOL_SP_IsValid(int value);
const SymbolStatic_SYMBOL_SP SymbolStatic_SYMBOL_SP_SYMBOL_SP_MIN = SymbolStatic_SYMBOL_SP_NULLSP;
const SymbolStatic_SYMBOL_SP SymbolStatic_SYMBOL_SP_SYMBOL_SP_MAX = SymbolStatic_SYMBOL_SP_ZSP;
const int SymbolStatic_SYMBOL_SP_SYMBOL_SP_ARRAYSIZE = SymbolStatic_SYMBOL_SP_SYMBOL_SP_MAX + 1;

const ::google::protobuf::EnumDescriptor* SymbolStatic_SYMBOL_SP_descriptor();
inline const ::std::string& SymbolStatic_SYMBOL_SP_Name(SymbolStatic_SYMBOL_SP value) {
  return ::google::protobuf::internal::NameOfEnum(
    SymbolStatic_SYMBOL_SP_descriptor(), value);
}
inline bool SymbolStatic_SYMBOL_SP_Parse(
    const ::std::string& name, SymbolStatic_SYMBOL_SP* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SymbolStatic_SYMBOL_SP>(
    SymbolStatic_SYMBOL_SP_descriptor(), name, value);
}
// ===================================================================

class SymbolStatic_EquityMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos_data.SymbolStatic.EquityMessage) */ {
 public:
  SymbolStatic_EquityMessage();
  virtual ~SymbolStatic_EquityMessage();

  SymbolStatic_EquityMessage(const SymbolStatic_EquityMessage& from);

  inline SymbolStatic_EquityMessage& operator=(const SymbolStatic_EquityMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SymbolStatic_EquityMessage(SymbolStatic_EquityMessage&& from) noexcept
    : SymbolStatic_EquityMessage() {
    *this = ::std::move(from);
  }

  inline SymbolStatic_EquityMessage& operator=(SymbolStatic_EquityMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolStatic_EquityMessage& default_instance();

  static inline const SymbolStatic_EquityMessage* internal_default_instance() {
    return reinterpret_cast<const SymbolStatic_EquityMessage*>(
               &_SymbolStatic_EquityMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(SymbolStatic_EquityMessage* other);
  friend void swap(SymbolStatic_EquityMessage& a, SymbolStatic_EquityMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SymbolStatic_EquityMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  SymbolStatic_EquityMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SymbolStatic_EquityMessage& from);
  void MergeFrom(const SymbolStatic_EquityMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SymbolStatic_EquityMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float face_value = 1;
  bool has_face_value() const;
  void clear_face_value();
  static const int kFaceValueFieldNumber = 1;
  float face_value() const;
  void set_face_value(float value);

  // optional float profit = 2;
  bool has_profit() const;
  void clear_profit();
  static const int kProfitFieldNumber = 2;
  float profit() const;
  void set_profit(float value);

  // optional uint32 industry = 3;
  bool has_industry() const;
  void clear_industry();
  static const int kIndustryFieldNumber = 3;
  ::google::protobuf::uint32 industry() const;
  void set_industry(::google::protobuf::uint32 value);

  // optional int32 trade_status = 4;
  bool has_trade_status() const;
  void clear_trade_status();
  static const int kTradeStatusFieldNumber = 4;
  ::google::protobuf::int32 trade_status() const;
  void set_trade_status(::google::protobuf::int32 value);

  // optional float cash_dividend = 5;
  bool has_cash_dividend() const;
  void clear_cash_dividend();
  static const int kCashDividendFieldNumber = 5;
  float cash_dividend() const;
  void set_cash_dividend(float value);

  // optional .chaos_data.SymbolStatic.SYMBOL_SP security_properties = 6;
  bool has_security_properties() const;
  void clear_security_properties();
  static const int kSecurityPropertiesFieldNumber = 6;
  ::chaos_data::SymbolStatic_SYMBOL_SP security_properties() const;
  void set_security_properties(::chaos_data::SymbolStatic_SYMBOL_SP value);

  // optional uint32 last_tradedate = 7;
  bool has_last_tradedate() const;
  void clear_last_tradedate();
  static const int kLastTradedateFieldNumber = 7;
  ::google::protobuf::uint32 last_tradedate() const;
  void set_last_tradedate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chaos_data.SymbolStatic.EquityMessage)
 private:
  void set_has_face_value();
  void clear_has_face_value();
  void set_has_profit();
  void clear_has_profit();
  void set_has_industry();
  void clear_has_industry();
  void set_has_trade_status();
  void clear_has_trade_status();
  void set_has_cash_dividend();
  void clear_has_cash_dividend();
  void set_has_security_properties();
  void clear_has_security_properties();
  void set_has_last_tradedate();
  void clear_has_last_tradedate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float face_value_;
  float profit_;
  ::google::protobuf::uint32 industry_;
  ::google::protobuf::int32 trade_status_;
  float cash_dividend_;
  int security_properties_;
  ::google::protobuf::uint32 last_tradedate_;
  friend struct protobuf_symbol_5fstatic_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SymbolStatic_FundMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos_data.SymbolStatic.FundMessage) */ {
 public:
  SymbolStatic_FundMessage();
  virtual ~SymbolStatic_FundMessage();

  SymbolStatic_FundMessage(const SymbolStatic_FundMessage& from);

  inline SymbolStatic_FundMessage& operator=(const SymbolStatic_FundMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SymbolStatic_FundMessage(SymbolStatic_FundMessage&& from) noexcept
    : SymbolStatic_FundMessage() {
    *this = ::std::move(from);
  }

  inline SymbolStatic_FundMessage& operator=(SymbolStatic_FundMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolStatic_FundMessage& default_instance();

  static inline const SymbolStatic_FundMessage* internal_default_instance() {
    return reinterpret_cast<const SymbolStatic_FundMessage*>(
               &_SymbolStatic_FundMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SymbolStatic_FundMessage* other);
  friend void swap(SymbolStatic_FundMessage& a, SymbolStatic_FundMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SymbolStatic_FundMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  SymbolStatic_FundMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SymbolStatic_FundMessage& from);
  void MergeFrom(const SymbolStatic_FundMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SymbolStatic_FundMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float face_value = 1;
  bool has_face_value() const;
  void clear_face_value();
  static const int kFaceValueFieldNumber = 1;
  float face_value() const;
  void set_face_value(float value);

  // optional float total_issued = 2;
  bool has_total_issued() const;
  void clear_total_issued();
  static const int kTotalIssuedFieldNumber = 2;
  float total_issued() const;
  void set_total_issued(float value);

  // optional float iopv = 3;
  bool has_iopv() const;
  void clear_iopv();
  static const int kIopvFieldNumber = 3;
  float iopv() const;
  void set_iopv(float value);

  // @@protoc_insertion_point(class_scope:chaos_data.SymbolStatic.FundMessage)
 private:
  void set_has_face_value();
  void clear_has_face_value();
  void set_has_total_issued();
  void clear_has_total_issued();
  void set_has_iopv();
  void clear_has_iopv();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float face_value_;
  float total_issued_;
  float iopv_;
  friend struct protobuf_symbol_5fstatic_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SymbolStatic_WarranMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos_data.SymbolStatic.WarranMessage) */ {
 public:
  SymbolStatic_WarranMessage();
  virtual ~SymbolStatic_WarranMessage();

  SymbolStatic_WarranMessage(const SymbolStatic_WarranMessage& from);

  inline SymbolStatic_WarranMessage& operator=(const SymbolStatic_WarranMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SymbolStatic_WarranMessage(SymbolStatic_WarranMessage&& from) noexcept
    : SymbolStatic_WarranMessage() {
    *this = ::std::move(from);
  }

  inline SymbolStatic_WarranMessage& operator=(SymbolStatic_WarranMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolStatic_WarranMessage& default_instance();

  static inline const SymbolStatic_WarranMessage* internal_default_instance() {
    return reinterpret_cast<const SymbolStatic_WarranMessage*>(
               &_SymbolStatic_WarranMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(SymbolStatic_WarranMessage* other);
  friend void swap(SymbolStatic_WarranMessage& a, SymbolStatic_WarranMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SymbolStatic_WarranMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  SymbolStatic_WarranMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SymbolStatic_WarranMessage& from);
  void MergeFrom(const SymbolStatic_WarranMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SymbolStatic_WarranMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes under_line = 6;
  bool has_under_line() const;
  void clear_under_line();
  static const int kUnderLineFieldNumber = 6;
  const ::std::string& under_line() const;
  void set_under_line(const ::std::string& value);
  #if LANG_CXX11
  void set_under_line(::std::string&& value);
  #endif
  void set_under_line(const char* value);
  void set_under_line(const void* value, size_t size);
  ::std::string* mutable_under_line();
  ::std::string* release_under_line();
  void set_allocated_under_line(::std::string* under_line);

  // optional int32 style = 1;
  bool has_style() const;
  void clear_style();
  static const int kStyleFieldNumber = 1;
  ::google::protobuf::int32 style() const;
  void set_style(::google::protobuf::int32 value);

  // optional int32 cp = 2;
  bool has_cp() const;
  void clear_cp();
  static const int kCpFieldNumber = 2;
  ::google::protobuf::int32 cp() const;
  void set_cp(::google::protobuf::int32 value);

  // optional float cnvt_ratio = 3;
  bool has_cnvt_ratio() const;
  void clear_cnvt_ratio();
  static const int kCnvtRatioFieldNumber = 3;
  float cnvt_ratio() const;
  void set_cnvt_ratio(float value);

  // optional float strike_price = 4;
  bool has_strike_price() const;
  void clear_strike_price();
  static const int kStrikePriceFieldNumber = 4;
  float strike_price() const;
  void set_strike_price(float value);

  // optional uint32 maturity_date = 5;
  bool has_maturity_date() const;
  void clear_maturity_date();
  static const int kMaturityDateFieldNumber = 5;
  ::google::protobuf::uint32 maturity_date() const;
  void set_maturity_date(::google::protobuf::uint32 value);

  // optional float balance = 7;
  bool has_balance() const;
  void clear_balance();
  static const int kBalanceFieldNumber = 7;
  float balance() const;
  void set_balance(float value);

  // @@protoc_insertion_point(class_scope:chaos_data.SymbolStatic.WarranMessage)
 private:
  void set_has_style();
  void clear_has_style();
  void set_has_cp();
  void clear_has_cp();
  void set_has_cnvt_ratio();
  void clear_has_cnvt_ratio();
  void set_has_strike_price();
  void clear_has_strike_price();
  void set_has_maturity_date();
  void clear_has_maturity_date();
  void set_has_under_line();
  void clear_has_under_line();
  void set_has_balance();
  void clear_has_balance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr under_line_;
  ::google::protobuf::int32 style_;
  ::google::protobuf::int32 cp_;
  float cnvt_ratio_;
  float strike_price_;
  ::google::protobuf::uint32 maturity_date_;
  float balance_;
  friend struct protobuf_symbol_5fstatic_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SymbolStatic_BoundMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos_data.SymbolStatic.BoundMessage) */ {
 public:
  SymbolStatic_BoundMessage();
  virtual ~SymbolStatic_BoundMessage();

  SymbolStatic_BoundMessage(const SymbolStatic_BoundMessage& from);

  inline SymbolStatic_BoundMessage& operator=(const SymbolStatic_BoundMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SymbolStatic_BoundMessage(SymbolStatic_BoundMessage&& from) noexcept
    : SymbolStatic_BoundMessage() {
    *this = ::std::move(from);
  }

  inline SymbolStatic_BoundMessage& operator=(SymbolStatic_BoundMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolStatic_BoundMessage& default_instance();

  static inline const SymbolStatic_BoundMessage* internal_default_instance() {
    return reinterpret_cast<const SymbolStatic_BoundMessage*>(
               &_SymbolStatic_BoundMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(SymbolStatic_BoundMessage* other);
  friend void swap(SymbolStatic_BoundMessage& a, SymbolStatic_BoundMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SymbolStatic_BoundMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  SymbolStatic_BoundMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SymbolStatic_BoundMessage& from);
  void MergeFrom(const SymbolStatic_BoundMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SymbolStatic_BoundMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 maturity_date = 1;
  bool has_maturity_date() const;
  void clear_maturity_date();
  static const int kMaturityDateFieldNumber = 1;
  ::google::protobuf::uint32 maturity_date() const;
  void set_maturity_date(::google::protobuf::uint32 value);

  // optional uint32 intaccru_date = 2;
  bool has_intaccru_date() const;
  void clear_intaccru_date();
  static const int kIntaccruDateFieldNumber = 2;
  ::google::protobuf::uint32 intaccru_date() const;
  void set_intaccru_date(::google::protobuf::uint32 value);

  // optional float isssue_price = 3;
  bool has_isssue_price() const;
  void clear_isssue_price();
  static const int kIsssuePriceFieldNumber = 3;
  float isssue_price() const;
  void set_isssue_price(float value);

  // optional float coupon_rate = 4;
  bool has_coupon_rate() const;
  void clear_coupon_rate();
  static const int kCouponRateFieldNumber = 4;
  float coupon_rate() const;
  void set_coupon_rate(float value);

  // optional float face_value = 5;
  bool has_face_value() const;
  void clear_face_value();
  static const int kFaceValueFieldNumber = 5;
  float face_value() const;
  void set_face_value(float value);

  // optional float accrued_int = 6;
  bool has_accrued_int() const;
  void clear_accrued_int();
  static const int kAccruedIntFieldNumber = 6;
  float accrued_int() const;
  void set_accrued_int(float value);

  // @@protoc_insertion_point(class_scope:chaos_data.SymbolStatic.BoundMessage)
 private:
  void set_has_maturity_date();
  void clear_has_maturity_date();
  void set_has_intaccru_date();
  void clear_has_intaccru_date();
  void set_has_isssue_price();
  void clear_has_isssue_price();
  void set_has_coupon_rate();
  void clear_has_coupon_rate();
  void set_has_face_value();
  void clear_has_face_value();
  void set_has_accrued_int();
  void clear_has_accrued_int();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 maturity_date_;
  ::google::protobuf::uint32 intaccru_date_;
  float isssue_price_;
  float coupon_rate_;
  float face_value_;
  float accrued_int_;
  friend struct protobuf_symbol_5fstatic_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SymbolStatic_CNVTMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos_data.SymbolStatic.CNVTMessage) */ {
 public:
  SymbolStatic_CNVTMessage();
  virtual ~SymbolStatic_CNVTMessage();

  SymbolStatic_CNVTMessage(const SymbolStatic_CNVTMessage& from);

  inline SymbolStatic_CNVTMessage& operator=(const SymbolStatic_CNVTMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SymbolStatic_CNVTMessage(SymbolStatic_CNVTMessage&& from) noexcept
    : SymbolStatic_CNVTMessage() {
    *this = ::std::move(from);
  }

  inline SymbolStatic_CNVTMessage& operator=(SymbolStatic_CNVTMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolStatic_CNVTMessage& default_instance();

  static inline const SymbolStatic_CNVTMessage* internal_default_instance() {
    return reinterpret_cast<const SymbolStatic_CNVTMessage*>(
               &_SymbolStatic_CNVTMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(SymbolStatic_CNVTMessage* other);
  friend void swap(SymbolStatic_CNVTMessage& a, SymbolStatic_CNVTMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SymbolStatic_CNVTMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  SymbolStatic_CNVTMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SymbolStatic_CNVTMessage& from);
  void MergeFrom(const SymbolStatic_CNVTMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SymbolStatic_CNVTMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes under_line = 6;
  bool has_under_line() const;
  void clear_under_line();
  static const int kUnderLineFieldNumber = 6;
  const ::std::string& under_line() const;
  void set_under_line(const ::std::string& value);
  #if LANG_CXX11
  void set_under_line(::std::string&& value);
  #endif
  void set_under_line(const char* value);
  void set_under_line(const void* value, size_t size);
  ::std::string* mutable_under_line();
  ::std::string* release_under_line();
  void set_allocated_under_line(::std::string* under_line);

  // optional int32 style = 1;
  bool has_style() const;
  void clear_style();
  static const int kStyleFieldNumber = 1;
  ::google::protobuf::int32 style() const;
  void set_style(::google::protobuf::int32 value);

  // optional int32 cp = 2;
  bool has_cp() const;
  void clear_cp();
  static const int kCpFieldNumber = 2;
  ::google::protobuf::int32 cp() const;
  void set_cp(::google::protobuf::int32 value);

  // optional float cnvt_ratio = 3;
  bool has_cnvt_ratio() const;
  void clear_cnvt_ratio();
  static const int kCnvtRatioFieldNumber = 3;
  float cnvt_ratio() const;
  void set_cnvt_ratio(float value);

  // optional float strike_price = 4;
  bool has_strike_price() const;
  void clear_strike_price();
  static const int kStrikePriceFieldNumber = 4;
  float strike_price() const;
  void set_strike_price(float value);

  // optional uint32 maturity_date = 5;
  bool has_maturity_date() const;
  void clear_maturity_date();
  static const int kMaturityDateFieldNumber = 5;
  ::google::protobuf::uint32 maturity_date() const;
  void set_maturity_date(::google::protobuf::uint32 value);

  // optional float accrued_int = 7;
  bool has_accrued_int() const;
  void clear_accrued_int();
  static const int kAccruedIntFieldNumber = 7;
  float accrued_int() const;
  void set_accrued_int(float value);

  // @@protoc_insertion_point(class_scope:chaos_data.SymbolStatic.CNVTMessage)
 private:
  void set_has_style();
  void clear_has_style();
  void set_has_cp();
  void clear_has_cp();
  void set_has_cnvt_ratio();
  void clear_has_cnvt_ratio();
  void set_has_strike_price();
  void clear_has_strike_price();
  void set_has_maturity_date();
  void clear_has_maturity_date();
  void set_has_under_line();
  void clear_has_under_line();
  void set_has_accrued_int();
  void clear_has_accrued_int();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr under_line_;
  ::google::protobuf::int32 style_;
  ::google::protobuf::int32 cp_;
  float cnvt_ratio_;
  float strike_price_;
  ::google::protobuf::uint32 maturity_date_;
  float accrued_int_;
  friend struct protobuf_symbol_5fstatic_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SymbolStatic_FutureMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos_data.SymbolStatic.FutureMessage) */ {
 public:
  SymbolStatic_FutureMessage();
  virtual ~SymbolStatic_FutureMessage();

  SymbolStatic_FutureMessage(const SymbolStatic_FutureMessage& from);

  inline SymbolStatic_FutureMessage& operator=(const SymbolStatic_FutureMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SymbolStatic_FutureMessage(SymbolStatic_FutureMessage&& from) noexcept
    : SymbolStatic_FutureMessage() {
    *this = ::std::move(from);
  }

  inline SymbolStatic_FutureMessage& operator=(SymbolStatic_FutureMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolStatic_FutureMessage& default_instance();

  static inline const SymbolStatic_FutureMessage* internal_default_instance() {
    return reinterpret_cast<const SymbolStatic_FutureMessage*>(
               &_SymbolStatic_FutureMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(SymbolStatic_FutureMessage* other);
  friend void swap(SymbolStatic_FutureMessage& a, SymbolStatic_FutureMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SymbolStatic_FutureMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  SymbolStatic_FutureMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SymbolStatic_FutureMessage& from);
  void MergeFrom(const SymbolStatic_FutureMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SymbolStatic_FutureMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 last_day_OI = 1;
  bool has_last_day_oi() const;
  void clear_last_day_oi();
  static const int kLastDayOIFieldNumber = 1;
  ::google::protobuf::uint32 last_day_oi() const;
  void set_last_day_oi(::google::protobuf::uint32 value);

  // optional float last_settle_price = 2;
  bool has_last_settle_price() const;
  void clear_last_settle_price();
  static const int kLastSettlePriceFieldNumber = 2;
  float last_settle_price() const;
  void set_last_settle_price(float value);

  // @@protoc_insertion_point(class_scope:chaos_data.SymbolStatic.FutureMessage)
 private:
  void set_has_last_day_oi();
  void clear_has_last_day_oi();
  void set_has_last_settle_price();
  void clear_has_last_settle_price();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 last_day_oi_;
  float last_settle_price_;
  friend struct protobuf_symbol_5fstatic_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SymbolStatic_TruestMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos_data.SymbolStatic.TruestMessage) */ {
 public:
  SymbolStatic_TruestMessage();
  virtual ~SymbolStatic_TruestMessage();

  SymbolStatic_TruestMessage(const SymbolStatic_TruestMessage& from);

  inline SymbolStatic_TruestMessage& operator=(const SymbolStatic_TruestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SymbolStatic_TruestMessage(SymbolStatic_TruestMessage&& from) noexcept
    : SymbolStatic_TruestMessage() {
    *this = ::std::move(from);
  }

  inline SymbolStatic_TruestMessage& operator=(SymbolStatic_TruestMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolStatic_TruestMessage& default_instance();

  static inline const SymbolStatic_TruestMessage* internal_default_instance() {
    return reinterpret_cast<const SymbolStatic_TruestMessage*>(
               &_SymbolStatic_TruestMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(SymbolStatic_TruestMessage* other);
  friend void swap(SymbolStatic_TruestMessage& a, SymbolStatic_TruestMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SymbolStatic_TruestMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  SymbolStatic_TruestMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SymbolStatic_TruestMessage& from);
  void MergeFrom(const SymbolStatic_TruestMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SymbolStatic_TruestMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float asset = 3;
  bool has_asset() const;
  void clear_asset();
  static const int kAssetFieldNumber = 3;
  float asset() const;
  void set_asset(float value);

  // optional uint32 asset_date = 4;
  bool has_asset_date() const;
  void clear_asset_date();
  static const int kAssetDateFieldNumber = 4;
  ::google::protobuf::uint32 asset_date() const;
  void set_asset_date(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chaos_data.SymbolStatic.TruestMessage)
 private:
  void set_has_asset();
  void clear_has_asset();
  void set_has_asset_date();
  void clear_has_asset_date();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float asset_;
  ::google::protobuf::uint32 asset_date_;
  friend struct protobuf_symbol_5fstatic_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SymbolStatic_SpecMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos_data.SymbolStatic.SpecMessage) */ {
 public:
  SymbolStatic_SpecMessage();
  virtual ~SymbolStatic_SpecMessage();

  SymbolStatic_SpecMessage(const SymbolStatic_SpecMessage& from);

  inline SymbolStatic_SpecMessage& operator=(const SymbolStatic_SpecMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SymbolStatic_SpecMessage(SymbolStatic_SpecMessage&& from) noexcept
    : SymbolStatic_SpecMessage() {
    *this = ::std::move(from);
  }

  inline SymbolStatic_SpecMessage& operator=(SymbolStatic_SpecMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolStatic_SpecMessage& default_instance();

  static inline const SymbolStatic_SpecMessage* internal_default_instance() {
    return reinterpret_cast<const SymbolStatic_SpecMessage*>(
               &_SymbolStatic_SpecMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(SymbolStatic_SpecMessage* other);
  friend void swap(SymbolStatic_SpecMessage& a, SymbolStatic_SpecMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SymbolStatic_SpecMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  SymbolStatic_SpecMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SymbolStatic_SpecMessage& from);
  void MergeFrom(const SymbolStatic_SpecMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SymbolStatic_SpecMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .chaos_data.SymbolStatic.EquityMessage equity = 1;
  bool has_equity() const;
  void clear_equity();
  static const int kEquityFieldNumber = 1;
  const ::chaos_data::SymbolStatic_EquityMessage& equity() const;
  ::chaos_data::SymbolStatic_EquityMessage* mutable_equity();
  ::chaos_data::SymbolStatic_EquityMessage* release_equity();
  void set_allocated_equity(::chaos_data::SymbolStatic_EquityMessage* equity);

  // optional .chaos_data.SymbolStatic.FundMessage fund = 2;
  bool has_fund() const;
  void clear_fund();
  static const int kFundFieldNumber = 2;
  const ::chaos_data::SymbolStatic_FundMessage& fund() const;
  ::chaos_data::SymbolStatic_FundMessage* mutable_fund();
  ::chaos_data::SymbolStatic_FundMessage* release_fund();
  void set_allocated_fund(::chaos_data::SymbolStatic_FundMessage* fund);

  // optional .chaos_data.SymbolStatic.WarranMessage warran = 3;
  bool has_warran() const;
  void clear_warran();
  static const int kWarranFieldNumber = 3;
  const ::chaos_data::SymbolStatic_WarranMessage& warran() const;
  ::chaos_data::SymbolStatic_WarranMessage* mutable_warran();
  ::chaos_data::SymbolStatic_WarranMessage* release_warran();
  void set_allocated_warran(::chaos_data::SymbolStatic_WarranMessage* warran);

  // optional .chaos_data.SymbolStatic.BoundMessage bound = 4;
  bool has_bound() const;
  void clear_bound();
  static const int kBoundFieldNumber = 4;
  const ::chaos_data::SymbolStatic_BoundMessage& bound() const;
  ::chaos_data::SymbolStatic_BoundMessage* mutable_bound();
  ::chaos_data::SymbolStatic_BoundMessage* release_bound();
  void set_allocated_bound(::chaos_data::SymbolStatic_BoundMessage* bound);

  // optional .chaos_data.SymbolStatic.CNVTMessage cnvt = 5;
  bool has_cnvt() const;
  void clear_cnvt();
  static const int kCnvtFieldNumber = 5;
  const ::chaos_data::SymbolStatic_CNVTMessage& cnvt() const;
  ::chaos_data::SymbolStatic_CNVTMessage* mutable_cnvt();
  ::chaos_data::SymbolStatic_CNVTMessage* release_cnvt();
  void set_allocated_cnvt(::chaos_data::SymbolStatic_CNVTMessage* cnvt);

  // optional .chaos_data.SymbolStatic.FutureMessage future = 6;
  bool has_future() const;
  void clear_future();
  static const int kFutureFieldNumber = 6;
  const ::chaos_data::SymbolStatic_FutureMessage& future() const;
  ::chaos_data::SymbolStatic_FutureMessage* mutable_future();
  ::chaos_data::SymbolStatic_FutureMessage* release_future();
  void set_allocated_future(::chaos_data::SymbolStatic_FutureMessage* future);

  // optional .chaos_data.SymbolStatic.TruestMessage truest = 7;
  bool has_truest() const;
  void clear_truest();
  static const int kTruestFieldNumber = 7;
  const ::chaos_data::SymbolStatic_TruestMessage& truest() const;
  ::chaos_data::SymbolStatic_TruestMessage* mutable_truest();
  ::chaos_data::SymbolStatic_TruestMessage* release_truest();
  void set_allocated_truest(::chaos_data::SymbolStatic_TruestMessage* truest);

  // @@protoc_insertion_point(class_scope:chaos_data.SymbolStatic.SpecMessage)
 private:
  void set_has_equity();
  void clear_has_equity();
  void set_has_fund();
  void clear_has_fund();
  void set_has_warran();
  void clear_has_warran();
  void set_has_bound();
  void clear_has_bound();
  void set_has_cnvt();
  void clear_has_cnvt();
  void set_has_future();
  void clear_has_future();
  void set_has_truest();
  void clear_has_truest();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::chaos_data::SymbolStatic_EquityMessage* equity_;
  ::chaos_data::SymbolStatic_FundMessage* fund_;
  ::chaos_data::SymbolStatic_WarranMessage* warran_;
  ::chaos_data::SymbolStatic_BoundMessage* bound_;
  ::chaos_data::SymbolStatic_CNVTMessage* cnvt_;
  ::chaos_data::SymbolStatic_FutureMessage* future_;
  ::chaos_data::SymbolStatic_TruestMessage* truest_;
  friend struct protobuf_symbol_5fstatic_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SymbolStatic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chaos_data.SymbolStatic) */ {
 public:
  SymbolStatic();
  virtual ~SymbolStatic();

  SymbolStatic(const SymbolStatic& from);

  inline SymbolStatic& operator=(const SymbolStatic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SymbolStatic(SymbolStatic&& from) noexcept
    : SymbolStatic() {
    *this = ::std::move(from);
  }

  inline SymbolStatic& operator=(SymbolStatic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolStatic& default_instance();

  static inline const SymbolStatic* internal_default_instance() {
    return reinterpret_cast<const SymbolStatic*>(
               &_SymbolStatic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(SymbolStatic* other);
  friend void swap(SymbolStatic& a, SymbolStatic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SymbolStatic* New() const PROTOBUF_FINAL { return New(NULL); }

  SymbolStatic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SymbolStatic& from);
  void MergeFrom(const SymbolStatic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SymbolStatic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SymbolStatic_EquityMessage EquityMessage;
  typedef SymbolStatic_FundMessage FundMessage;
  typedef SymbolStatic_WarranMessage WarranMessage;
  typedef SymbolStatic_BoundMessage BoundMessage;
  typedef SymbolStatic_CNVTMessage CNVTMessage;
  typedef SymbolStatic_FutureMessage FutureMessage;
  typedef SymbolStatic_TruestMessage TruestMessage;
  typedef SymbolStatic_SpecMessage SpecMessage;

  typedef SymbolStatic_SYMBOL_TYPE SYMBOL_TYPE;
  static const SYMBOL_TYPE INDEX =
    SymbolStatic_SYMBOL_TYPE_INDEX;
  static const SYMBOL_TYPE STOCK =
    SymbolStatic_SYMBOL_TYPE_STOCK;
  static const SYMBOL_TYPE FUND =
    SymbolStatic_SYMBOL_TYPE_FUND;
  static const SYMBOL_TYPE BOND =
    SymbolStatic_SYMBOL_TYPE_BOND;
  static const SYMBOL_TYPE OTHER_STOCK =
    SymbolStatic_SYMBOL_TYPE_OTHER_STOCK;
  static const SYMBOL_TYPE OPTION =
    SymbolStatic_SYMBOL_TYPE_OPTION;
  static const SYMBOL_TYPE EXCHANGE =
    SymbolStatic_SYMBOL_TYPE_EXCHANGE;
  static const SYMBOL_TYPE FUTURE =
    SymbolStatic_SYMBOL_TYPE_FUTURE;
  static const SYMBOL_TYPE FTR_IDX =
    SymbolStatic_SYMBOL_TYPE_FTR_IDX;
  static const SYMBOL_TYPE RGZ =
    SymbolStatic_SYMBOL_TYPE_RGZ;
  static const SYMBOL_TYPE ETF =
    SymbolStatic_SYMBOL_TYPE_ETF;
  static const SYMBOL_TYPE LOF =
    SymbolStatic_SYMBOL_TYPE_LOF;
  static const SYMBOL_TYPE COV_BOND =
    SymbolStatic_SYMBOL_TYPE_COV_BOND;
  static const SYMBOL_TYPE TRUST =
    SymbolStatic_SYMBOL_TYPE_TRUST;
  static const SYMBOL_TYPE WARRANT =
    SymbolStatic_SYMBOL_TYPE_WARRANT;
  static const SYMBOL_TYPE REPO =
    SymbolStatic_SYMBOL_TYPE_REPO;
  static const SYMBOL_TYPE COMM =
    SymbolStatic_SYMBOL_TYPE_COMM;
  static inline bool SYMBOL_TYPE_IsValid(int value) {
    return SymbolStatic_SYMBOL_TYPE_IsValid(value);
  }
  static const SYMBOL_TYPE SYMBOL_TYPE_MIN =
    SymbolStatic_SYMBOL_TYPE_SYMBOL_TYPE_MIN;
  static const SYMBOL_TYPE SYMBOL_TYPE_MAX =
    SymbolStatic_SYMBOL_TYPE_SYMBOL_TYPE_MAX;
  static const int SYMBOL_TYPE_ARRAYSIZE =
    SymbolStatic_SYMBOL_TYPE_SYMBOL_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SYMBOL_TYPE_descriptor() {
    return SymbolStatic_SYMBOL_TYPE_descriptor();
  }
  static inline const ::std::string& SYMBOL_TYPE_Name(SYMBOL_TYPE value) {
    return SymbolStatic_SYMBOL_TYPE_Name(value);
  }
  static inline bool SYMBOL_TYPE_Parse(const ::std::string& name,
      SYMBOL_TYPE* value) {
    return SymbolStatic_SYMBOL_TYPE_Parse(name, value);
  }

  typedef SymbolStatic_SYMBOL_SUBTYPE SYMBOL_SUBTYPE;
  static const SYMBOL_SUBTYPE NILTYPE =
    SymbolStatic_SYMBOL_SUBTYPE_NILTYPE;
  static const SYMBOL_SUBTYPE ASHARE =
    SymbolStatic_SYMBOL_SUBTYPE_ASHARE;
  static const SYMBOL_SUBTYPE BSHARE =
    SymbolStatic_SYMBOL_SUBTYPE_BSHARE;
  static const SYMBOL_SUBTYPE GOV_BOND =
    SymbolStatic_SYMBOL_SUBTYPE_GOV_BOND;
  static const SYMBOL_SUBTYPE ENT_BOND =
    SymbolStatic_SYMBOL_SUBTYPE_ENT_BOND;
  static const SYMBOL_SUBTYPE FIN_BOND =
    SymbolStatic_SYMBOL_SUBTYPE_FIN_BOND;
  static inline bool SYMBOL_SUBTYPE_IsValid(int value) {
    return SymbolStatic_SYMBOL_SUBTYPE_IsValid(value);
  }
  static const SYMBOL_SUBTYPE SYMBOL_SUBTYPE_MIN =
    SymbolStatic_SYMBOL_SUBTYPE_SYMBOL_SUBTYPE_MIN;
  static const SYMBOL_SUBTYPE SYMBOL_SUBTYPE_MAX =
    SymbolStatic_SYMBOL_SUBTYPE_SYMBOL_SUBTYPE_MAX;
  static const int SYMBOL_SUBTYPE_ARRAYSIZE =
    SymbolStatic_SYMBOL_SUBTYPE_SYMBOL_SUBTYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SYMBOL_SUBTYPE_descriptor() {
    return SymbolStatic_SYMBOL_SUBTYPE_descriptor();
  }
  static inline const ::std::string& SYMBOL_SUBTYPE_Name(SYMBOL_SUBTYPE value) {
    return SymbolStatic_SYMBOL_SUBTYPE_Name(value);
  }
  static inline bool SYMBOL_SUBTYPE_Parse(const ::std::string& name,
      SYMBOL_SUBTYPE* value) {
    return SymbolStatic_SYMBOL_SUBTYPE_Parse(name, value);
  }

  typedef SymbolStatic_SYMBOL_SP SYMBOL_SP;
  static const SYMBOL_SP NULLSP =
    SymbolStatic_SYMBOL_SP_NULLSP;
  static const SYMBOL_SP NSP =
    SymbolStatic_SYMBOL_SP_NSP;
  static const SYMBOL_SP SSP =
    SymbolStatic_SYMBOL_SP_SSP;
  static const SYMBOL_SP PSP =
    SymbolStatic_SYMBOL_SP_PSP;
  static const SYMBOL_SP TSP =
    SymbolStatic_SYMBOL_SP_TSP;
  static const SYMBOL_SP LSP =
    SymbolStatic_SYMBOL_SP_LSP;
  static const SYMBOL_SP OSP =
    SymbolStatic_SYMBOL_SP_OSP;
  static const SYMBOL_SP FSP =
    SymbolStatic_SYMBOL_SP_FSP;
  static const SYMBOL_SP ESP =
    SymbolStatic_SYMBOL_SP_ESP;
  static const SYMBOL_SP ZSP =
    SymbolStatic_SYMBOL_SP_ZSP;
  static inline bool SYMBOL_SP_IsValid(int value) {
    return SymbolStatic_SYMBOL_SP_IsValid(value);
  }
  static const SYMBOL_SP SYMBOL_SP_MIN =
    SymbolStatic_SYMBOL_SP_SYMBOL_SP_MIN;
  static const SYMBOL_SP SYMBOL_SP_MAX =
    SymbolStatic_SYMBOL_SP_SYMBOL_SP_MAX;
  static const int SYMBOL_SP_ARRAYSIZE =
    SymbolStatic_SYMBOL_SP_SYMBOL_SP_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SYMBOL_SP_descriptor() {
    return SymbolStatic_SYMBOL_SP_descriptor();
  }
  static inline const ::std::string& SYMBOL_SP_Name(SYMBOL_SP value) {
    return SymbolStatic_SYMBOL_SP_Name(value);
  }
  static inline bool SYMBOL_SP_Parse(const ::std::string& name,
      SYMBOL_SP* value) {
    return SymbolStatic_SYMBOL_SP_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes symbol = 1;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const void* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional bytes name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .chaos_data.SymbolStatic.SpecMessage spec = 12;
  bool has_spec() const;
  void clear_spec();
  static const int kSpecFieldNumber = 12;
  const ::chaos_data::SymbolStatic_SpecMessage& spec() const;
  ::chaos_data::SymbolStatic_SpecMessage* mutable_spec();
  ::chaos_data::SymbolStatic_SpecMessage* release_spec();
  void set_allocated_spec(::chaos_data::SymbolStatic_SpecMessage* spec);

  // optional .chaos_data.SymbolStatic.SYMBOL_TYPE ctype = 3;
  bool has_ctype() const;
  void clear_ctype();
  static const int kCtypeFieldNumber = 3;
  ::chaos_data::SymbolStatic_SYMBOL_TYPE ctype() const;
  void set_ctype(::chaos_data::SymbolStatic_SYMBOL_TYPE value);

  // optional .chaos_data.SymbolStatic.SYMBOL_SUBTYPE csub_type = 4;
  bool has_csub_type() const;
  void clear_csub_type();
  static const int kCsubTypeFieldNumber = 4;
  ::chaos_data::SymbolStatic_SYMBOL_SUBTYPE csub_type() const;
  void set_csub_type(::chaos_data::SymbolStatic_SYMBOL_SUBTYPE value);

  // optional uint32 price_digit = 5;
  bool has_price_digit() const;
  void clear_price_digit();
  static const int kPriceDigitFieldNumber = 5;
  ::google::protobuf::uint32 price_digit() const;
  void set_price_digit(::google::protobuf::uint32 value);

  // optional int32 vol_unit = 6;
  bool has_vol_unit() const;
  void clear_vol_unit();
  static const int kVolUnitFieldNumber = 6;
  ::google::protobuf::int32 vol_unit() const;
  void set_vol_unit(::google::protobuf::int32 value);

  // optional int64 float_issued = 7;
  bool has_float_issued() const;
  void clear_float_issued();
  static const int kFloatIssuedFieldNumber = 7;
  ::google::protobuf::int64 float_issued() const;
  void set_float_issued(::google::protobuf::int64 value);

  // optional int64 total_issued = 8;
  bool has_total_issued() const;
  void clear_total_issued();
  static const int kTotalIssuedFieldNumber = 8;
  ::google::protobuf::int64 total_issued() const;
  void set_total_issued(::google::protobuf::int64 value);

  // optional uint32 last_close = 9;
  bool has_last_close() const;
  void clear_last_close();
  static const int kLastCloseFieldNumber = 9;
  ::google::protobuf::uint32 last_close() const;
  void set_last_close(::google::protobuf::uint32 value);

  // optional uint32 adv_stop = 10;
  bool has_adv_stop() const;
  void clear_adv_stop();
  static const int kAdvStopFieldNumber = 10;
  ::google::protobuf::uint32 adv_stop() const;
  void set_adv_stop(::google::protobuf::uint32 value);

  // optional uint32 dec_stop = 11;
  bool has_dec_stop() const;
  void clear_dec_stop();
  static const int kDecStopFieldNumber = 11;
  ::google::protobuf::uint32 dec_stop() const;
  void set_dec_stop(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chaos_data.SymbolStatic)
 private:
  void set_has_symbol();
  void clear_has_symbol();
  void set_has_name();
  void clear_has_name();
  void set_has_ctype();
  void clear_has_ctype();
  void set_has_csub_type();
  void clear_has_csub_type();
  void set_has_price_digit();
  void clear_has_price_digit();
  void set_has_vol_unit();
  void clear_has_vol_unit();
  void set_has_float_issued();
  void clear_has_float_issued();
  void set_has_total_issued();
  void clear_has_total_issued();
  void set_has_last_close();
  void clear_has_last_close();
  void set_has_adv_stop();
  void clear_has_adv_stop();
  void set_has_dec_stop();
  void clear_has_dec_stop();
  void set_has_spec();
  void clear_has_spec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::chaos_data::SymbolStatic_SpecMessage* spec_;
  int ctype_;
  int csub_type_;
  ::google::protobuf::uint32 price_digit_;
  ::google::protobuf::int32 vol_unit_;
  ::google::protobuf::int64 float_issued_;
  ::google::protobuf::int64 total_issued_;
  ::google::protobuf::uint32 last_close_;
  ::google::protobuf::uint32 adv_stop_;
  ::google::protobuf::uint32 dec_stop_;
  friend struct protobuf_symbol_5fstatic_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SymbolStatic_EquityMessage

// optional float face_value = 1;
inline bool SymbolStatic_EquityMessage::has_face_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolStatic_EquityMessage::set_has_face_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolStatic_EquityMessage::clear_has_face_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolStatic_EquityMessage::clear_face_value() {
  face_value_ = 0;
  clear_has_face_value();
}
inline float SymbolStatic_EquityMessage::face_value() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.EquityMessage.face_value)
  return face_value_;
}
inline void SymbolStatic_EquityMessage::set_face_value(float value) {
  set_has_face_value();
  face_value_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.EquityMessage.face_value)
}

// optional float profit = 2;
inline bool SymbolStatic_EquityMessage::has_profit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolStatic_EquityMessage::set_has_profit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolStatic_EquityMessage::clear_has_profit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolStatic_EquityMessage::clear_profit() {
  profit_ = 0;
  clear_has_profit();
}
inline float SymbolStatic_EquityMessage::profit() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.EquityMessage.profit)
  return profit_;
}
inline void SymbolStatic_EquityMessage::set_profit(float value) {
  set_has_profit();
  profit_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.EquityMessage.profit)
}

// optional uint32 industry = 3;
inline bool SymbolStatic_EquityMessage::has_industry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolStatic_EquityMessage::set_has_industry() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolStatic_EquityMessage::clear_has_industry() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolStatic_EquityMessage::clear_industry() {
  industry_ = 0u;
  clear_has_industry();
}
inline ::google::protobuf::uint32 SymbolStatic_EquityMessage::industry() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.EquityMessage.industry)
  return industry_;
}
inline void SymbolStatic_EquityMessage::set_industry(::google::protobuf::uint32 value) {
  set_has_industry();
  industry_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.EquityMessage.industry)
}

// optional int32 trade_status = 4;
inline bool SymbolStatic_EquityMessage::has_trade_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymbolStatic_EquityMessage::set_has_trade_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymbolStatic_EquityMessage::clear_has_trade_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymbolStatic_EquityMessage::clear_trade_status() {
  trade_status_ = 0;
  clear_has_trade_status();
}
inline ::google::protobuf::int32 SymbolStatic_EquityMessage::trade_status() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.EquityMessage.trade_status)
  return trade_status_;
}
inline void SymbolStatic_EquityMessage::set_trade_status(::google::protobuf::int32 value) {
  set_has_trade_status();
  trade_status_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.EquityMessage.trade_status)
}

// optional float cash_dividend = 5;
inline bool SymbolStatic_EquityMessage::has_cash_dividend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SymbolStatic_EquityMessage::set_has_cash_dividend() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SymbolStatic_EquityMessage::clear_has_cash_dividend() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SymbolStatic_EquityMessage::clear_cash_dividend() {
  cash_dividend_ = 0;
  clear_has_cash_dividend();
}
inline float SymbolStatic_EquityMessage::cash_dividend() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.EquityMessage.cash_dividend)
  return cash_dividend_;
}
inline void SymbolStatic_EquityMessage::set_cash_dividend(float value) {
  set_has_cash_dividend();
  cash_dividend_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.EquityMessage.cash_dividend)
}

// optional .chaos_data.SymbolStatic.SYMBOL_SP security_properties = 6;
inline bool SymbolStatic_EquityMessage::has_security_properties() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SymbolStatic_EquityMessage::set_has_security_properties() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SymbolStatic_EquityMessage::clear_has_security_properties() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SymbolStatic_EquityMessage::clear_security_properties() {
  security_properties_ = 0;
  clear_has_security_properties();
}
inline ::chaos_data::SymbolStatic_SYMBOL_SP SymbolStatic_EquityMessage::security_properties() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.EquityMessage.security_properties)
  return static_cast< ::chaos_data::SymbolStatic_SYMBOL_SP >(security_properties_);
}
inline void SymbolStatic_EquityMessage::set_security_properties(::chaos_data::SymbolStatic_SYMBOL_SP value) {
  assert(::chaos_data::SymbolStatic_SYMBOL_SP_IsValid(value));
  set_has_security_properties();
  security_properties_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.EquityMessage.security_properties)
}

// optional uint32 last_tradedate = 7;
inline bool SymbolStatic_EquityMessage::has_last_tradedate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SymbolStatic_EquityMessage::set_has_last_tradedate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SymbolStatic_EquityMessage::clear_has_last_tradedate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SymbolStatic_EquityMessage::clear_last_tradedate() {
  last_tradedate_ = 0u;
  clear_has_last_tradedate();
}
inline ::google::protobuf::uint32 SymbolStatic_EquityMessage::last_tradedate() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.EquityMessage.last_tradedate)
  return last_tradedate_;
}
inline void SymbolStatic_EquityMessage::set_last_tradedate(::google::protobuf::uint32 value) {
  set_has_last_tradedate();
  last_tradedate_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.EquityMessage.last_tradedate)
}

// -------------------------------------------------------------------

// SymbolStatic_FundMessage

// optional float face_value = 1;
inline bool SymbolStatic_FundMessage::has_face_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolStatic_FundMessage::set_has_face_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolStatic_FundMessage::clear_has_face_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolStatic_FundMessage::clear_face_value() {
  face_value_ = 0;
  clear_has_face_value();
}
inline float SymbolStatic_FundMessage::face_value() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.FundMessage.face_value)
  return face_value_;
}
inline void SymbolStatic_FundMessage::set_face_value(float value) {
  set_has_face_value();
  face_value_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.FundMessage.face_value)
}

// optional float total_issued = 2;
inline bool SymbolStatic_FundMessage::has_total_issued() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolStatic_FundMessage::set_has_total_issued() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolStatic_FundMessage::clear_has_total_issued() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolStatic_FundMessage::clear_total_issued() {
  total_issued_ = 0;
  clear_has_total_issued();
}
inline float SymbolStatic_FundMessage::total_issued() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.FundMessage.total_issued)
  return total_issued_;
}
inline void SymbolStatic_FundMessage::set_total_issued(float value) {
  set_has_total_issued();
  total_issued_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.FundMessage.total_issued)
}

// optional float iopv = 3;
inline bool SymbolStatic_FundMessage::has_iopv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolStatic_FundMessage::set_has_iopv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolStatic_FundMessage::clear_has_iopv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolStatic_FundMessage::clear_iopv() {
  iopv_ = 0;
  clear_has_iopv();
}
inline float SymbolStatic_FundMessage::iopv() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.FundMessage.iopv)
  return iopv_;
}
inline void SymbolStatic_FundMessage::set_iopv(float value) {
  set_has_iopv();
  iopv_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.FundMessage.iopv)
}

// -------------------------------------------------------------------

// SymbolStatic_WarranMessage

// optional int32 style = 1;
inline bool SymbolStatic_WarranMessage::has_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolStatic_WarranMessage::set_has_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolStatic_WarranMessage::clear_has_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolStatic_WarranMessage::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 SymbolStatic_WarranMessage::style() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.WarranMessage.style)
  return style_;
}
inline void SymbolStatic_WarranMessage::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.WarranMessage.style)
}

// optional int32 cp = 2;
inline bool SymbolStatic_WarranMessage::has_cp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolStatic_WarranMessage::set_has_cp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolStatic_WarranMessage::clear_has_cp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolStatic_WarranMessage::clear_cp() {
  cp_ = 0;
  clear_has_cp();
}
inline ::google::protobuf::int32 SymbolStatic_WarranMessage::cp() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.WarranMessage.cp)
  return cp_;
}
inline void SymbolStatic_WarranMessage::set_cp(::google::protobuf::int32 value) {
  set_has_cp();
  cp_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.WarranMessage.cp)
}

// optional float cnvt_ratio = 3;
inline bool SymbolStatic_WarranMessage::has_cnvt_ratio() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymbolStatic_WarranMessage::set_has_cnvt_ratio() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymbolStatic_WarranMessage::clear_has_cnvt_ratio() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymbolStatic_WarranMessage::clear_cnvt_ratio() {
  cnvt_ratio_ = 0;
  clear_has_cnvt_ratio();
}
inline float SymbolStatic_WarranMessage::cnvt_ratio() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.WarranMessage.cnvt_ratio)
  return cnvt_ratio_;
}
inline void SymbolStatic_WarranMessage::set_cnvt_ratio(float value) {
  set_has_cnvt_ratio();
  cnvt_ratio_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.WarranMessage.cnvt_ratio)
}

// optional float strike_price = 4;
inline bool SymbolStatic_WarranMessage::has_strike_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SymbolStatic_WarranMessage::set_has_strike_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SymbolStatic_WarranMessage::clear_has_strike_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SymbolStatic_WarranMessage::clear_strike_price() {
  strike_price_ = 0;
  clear_has_strike_price();
}
inline float SymbolStatic_WarranMessage::strike_price() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.WarranMessage.strike_price)
  return strike_price_;
}
inline void SymbolStatic_WarranMessage::set_strike_price(float value) {
  set_has_strike_price();
  strike_price_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.WarranMessage.strike_price)
}

// optional uint32 maturity_date = 5;
inline bool SymbolStatic_WarranMessage::has_maturity_date() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SymbolStatic_WarranMessage::set_has_maturity_date() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SymbolStatic_WarranMessage::clear_has_maturity_date() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SymbolStatic_WarranMessage::clear_maturity_date() {
  maturity_date_ = 0u;
  clear_has_maturity_date();
}
inline ::google::protobuf::uint32 SymbolStatic_WarranMessage::maturity_date() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.WarranMessage.maturity_date)
  return maturity_date_;
}
inline void SymbolStatic_WarranMessage::set_maturity_date(::google::protobuf::uint32 value) {
  set_has_maturity_date();
  maturity_date_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.WarranMessage.maturity_date)
}

// optional bytes under_line = 6;
inline bool SymbolStatic_WarranMessage::has_under_line() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolStatic_WarranMessage::set_has_under_line() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolStatic_WarranMessage::clear_has_under_line() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolStatic_WarranMessage::clear_under_line() {
  under_line_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_under_line();
}
inline const ::std::string& SymbolStatic_WarranMessage::under_line() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.WarranMessage.under_line)
  return under_line_.GetNoArena();
}
inline void SymbolStatic_WarranMessage::set_under_line(const ::std::string& value) {
  set_has_under_line();
  under_line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.WarranMessage.under_line)
}
#if LANG_CXX11
inline void SymbolStatic_WarranMessage::set_under_line(::std::string&& value) {
  set_has_under_line();
  under_line_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chaos_data.SymbolStatic.WarranMessage.under_line)
}
#endif
inline void SymbolStatic_WarranMessage::set_under_line(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_under_line();
  under_line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos_data.SymbolStatic.WarranMessage.under_line)
}
inline void SymbolStatic_WarranMessage::set_under_line(const void* value, size_t size) {
  set_has_under_line();
  under_line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos_data.SymbolStatic.WarranMessage.under_line)
}
inline ::std::string* SymbolStatic_WarranMessage::mutable_under_line() {
  set_has_under_line();
  // @@protoc_insertion_point(field_mutable:chaos_data.SymbolStatic.WarranMessage.under_line)
  return under_line_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymbolStatic_WarranMessage::release_under_line() {
  // @@protoc_insertion_point(field_release:chaos_data.SymbolStatic.WarranMessage.under_line)
  clear_has_under_line();
  return under_line_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymbolStatic_WarranMessage::set_allocated_under_line(::std::string* under_line) {
  if (under_line != NULL) {
    set_has_under_line();
  } else {
    clear_has_under_line();
  }
  under_line_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), under_line);
  // @@protoc_insertion_point(field_set_allocated:chaos_data.SymbolStatic.WarranMessage.under_line)
}

// optional float balance = 7;
inline bool SymbolStatic_WarranMessage::has_balance() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SymbolStatic_WarranMessage::set_has_balance() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SymbolStatic_WarranMessage::clear_has_balance() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SymbolStatic_WarranMessage::clear_balance() {
  balance_ = 0;
  clear_has_balance();
}
inline float SymbolStatic_WarranMessage::balance() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.WarranMessage.balance)
  return balance_;
}
inline void SymbolStatic_WarranMessage::set_balance(float value) {
  set_has_balance();
  balance_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.WarranMessage.balance)
}

// -------------------------------------------------------------------

// SymbolStatic_BoundMessage

// optional uint32 maturity_date = 1;
inline bool SymbolStatic_BoundMessage::has_maturity_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolStatic_BoundMessage::set_has_maturity_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolStatic_BoundMessage::clear_has_maturity_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolStatic_BoundMessage::clear_maturity_date() {
  maturity_date_ = 0u;
  clear_has_maturity_date();
}
inline ::google::protobuf::uint32 SymbolStatic_BoundMessage::maturity_date() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.BoundMessage.maturity_date)
  return maturity_date_;
}
inline void SymbolStatic_BoundMessage::set_maturity_date(::google::protobuf::uint32 value) {
  set_has_maturity_date();
  maturity_date_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.BoundMessage.maturity_date)
}

// optional uint32 intaccru_date = 2;
inline bool SymbolStatic_BoundMessage::has_intaccru_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolStatic_BoundMessage::set_has_intaccru_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolStatic_BoundMessage::clear_has_intaccru_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolStatic_BoundMessage::clear_intaccru_date() {
  intaccru_date_ = 0u;
  clear_has_intaccru_date();
}
inline ::google::protobuf::uint32 SymbolStatic_BoundMessage::intaccru_date() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.BoundMessage.intaccru_date)
  return intaccru_date_;
}
inline void SymbolStatic_BoundMessage::set_intaccru_date(::google::protobuf::uint32 value) {
  set_has_intaccru_date();
  intaccru_date_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.BoundMessage.intaccru_date)
}

// optional float isssue_price = 3;
inline bool SymbolStatic_BoundMessage::has_isssue_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolStatic_BoundMessage::set_has_isssue_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolStatic_BoundMessage::clear_has_isssue_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolStatic_BoundMessage::clear_isssue_price() {
  isssue_price_ = 0;
  clear_has_isssue_price();
}
inline float SymbolStatic_BoundMessage::isssue_price() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.BoundMessage.isssue_price)
  return isssue_price_;
}
inline void SymbolStatic_BoundMessage::set_isssue_price(float value) {
  set_has_isssue_price();
  isssue_price_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.BoundMessage.isssue_price)
}

// optional float coupon_rate = 4;
inline bool SymbolStatic_BoundMessage::has_coupon_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymbolStatic_BoundMessage::set_has_coupon_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymbolStatic_BoundMessage::clear_has_coupon_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymbolStatic_BoundMessage::clear_coupon_rate() {
  coupon_rate_ = 0;
  clear_has_coupon_rate();
}
inline float SymbolStatic_BoundMessage::coupon_rate() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.BoundMessage.coupon_rate)
  return coupon_rate_;
}
inline void SymbolStatic_BoundMessage::set_coupon_rate(float value) {
  set_has_coupon_rate();
  coupon_rate_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.BoundMessage.coupon_rate)
}

// optional float face_value = 5;
inline bool SymbolStatic_BoundMessage::has_face_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SymbolStatic_BoundMessage::set_has_face_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SymbolStatic_BoundMessage::clear_has_face_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SymbolStatic_BoundMessage::clear_face_value() {
  face_value_ = 0;
  clear_has_face_value();
}
inline float SymbolStatic_BoundMessage::face_value() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.BoundMessage.face_value)
  return face_value_;
}
inline void SymbolStatic_BoundMessage::set_face_value(float value) {
  set_has_face_value();
  face_value_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.BoundMessage.face_value)
}

// optional float accrued_int = 6;
inline bool SymbolStatic_BoundMessage::has_accrued_int() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SymbolStatic_BoundMessage::set_has_accrued_int() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SymbolStatic_BoundMessage::clear_has_accrued_int() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SymbolStatic_BoundMessage::clear_accrued_int() {
  accrued_int_ = 0;
  clear_has_accrued_int();
}
inline float SymbolStatic_BoundMessage::accrued_int() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.BoundMessage.accrued_int)
  return accrued_int_;
}
inline void SymbolStatic_BoundMessage::set_accrued_int(float value) {
  set_has_accrued_int();
  accrued_int_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.BoundMessage.accrued_int)
}

// -------------------------------------------------------------------

// SymbolStatic_CNVTMessage

// optional int32 style = 1;
inline bool SymbolStatic_CNVTMessage::has_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolStatic_CNVTMessage::set_has_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolStatic_CNVTMessage::clear_has_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolStatic_CNVTMessage::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 SymbolStatic_CNVTMessage::style() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.CNVTMessage.style)
  return style_;
}
inline void SymbolStatic_CNVTMessage::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.CNVTMessage.style)
}

// optional int32 cp = 2;
inline bool SymbolStatic_CNVTMessage::has_cp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolStatic_CNVTMessage::set_has_cp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolStatic_CNVTMessage::clear_has_cp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolStatic_CNVTMessage::clear_cp() {
  cp_ = 0;
  clear_has_cp();
}
inline ::google::protobuf::int32 SymbolStatic_CNVTMessage::cp() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.CNVTMessage.cp)
  return cp_;
}
inline void SymbolStatic_CNVTMessage::set_cp(::google::protobuf::int32 value) {
  set_has_cp();
  cp_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.CNVTMessage.cp)
}

// optional float cnvt_ratio = 3;
inline bool SymbolStatic_CNVTMessage::has_cnvt_ratio() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymbolStatic_CNVTMessage::set_has_cnvt_ratio() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymbolStatic_CNVTMessage::clear_has_cnvt_ratio() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymbolStatic_CNVTMessage::clear_cnvt_ratio() {
  cnvt_ratio_ = 0;
  clear_has_cnvt_ratio();
}
inline float SymbolStatic_CNVTMessage::cnvt_ratio() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.CNVTMessage.cnvt_ratio)
  return cnvt_ratio_;
}
inline void SymbolStatic_CNVTMessage::set_cnvt_ratio(float value) {
  set_has_cnvt_ratio();
  cnvt_ratio_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.CNVTMessage.cnvt_ratio)
}

// optional float strike_price = 4;
inline bool SymbolStatic_CNVTMessage::has_strike_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SymbolStatic_CNVTMessage::set_has_strike_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SymbolStatic_CNVTMessage::clear_has_strike_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SymbolStatic_CNVTMessage::clear_strike_price() {
  strike_price_ = 0;
  clear_has_strike_price();
}
inline float SymbolStatic_CNVTMessage::strike_price() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.CNVTMessage.strike_price)
  return strike_price_;
}
inline void SymbolStatic_CNVTMessage::set_strike_price(float value) {
  set_has_strike_price();
  strike_price_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.CNVTMessage.strike_price)
}

// optional uint32 maturity_date = 5;
inline bool SymbolStatic_CNVTMessage::has_maturity_date() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SymbolStatic_CNVTMessage::set_has_maturity_date() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SymbolStatic_CNVTMessage::clear_has_maturity_date() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SymbolStatic_CNVTMessage::clear_maturity_date() {
  maturity_date_ = 0u;
  clear_has_maturity_date();
}
inline ::google::protobuf::uint32 SymbolStatic_CNVTMessage::maturity_date() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.CNVTMessage.maturity_date)
  return maturity_date_;
}
inline void SymbolStatic_CNVTMessage::set_maturity_date(::google::protobuf::uint32 value) {
  set_has_maturity_date();
  maturity_date_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.CNVTMessage.maturity_date)
}

// optional bytes under_line = 6;
inline bool SymbolStatic_CNVTMessage::has_under_line() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolStatic_CNVTMessage::set_has_under_line() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolStatic_CNVTMessage::clear_has_under_line() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolStatic_CNVTMessage::clear_under_line() {
  under_line_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_under_line();
}
inline const ::std::string& SymbolStatic_CNVTMessage::under_line() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.CNVTMessage.under_line)
  return under_line_.GetNoArena();
}
inline void SymbolStatic_CNVTMessage::set_under_line(const ::std::string& value) {
  set_has_under_line();
  under_line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.CNVTMessage.under_line)
}
#if LANG_CXX11
inline void SymbolStatic_CNVTMessage::set_under_line(::std::string&& value) {
  set_has_under_line();
  under_line_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chaos_data.SymbolStatic.CNVTMessage.under_line)
}
#endif
inline void SymbolStatic_CNVTMessage::set_under_line(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_under_line();
  under_line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos_data.SymbolStatic.CNVTMessage.under_line)
}
inline void SymbolStatic_CNVTMessage::set_under_line(const void* value, size_t size) {
  set_has_under_line();
  under_line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos_data.SymbolStatic.CNVTMessage.under_line)
}
inline ::std::string* SymbolStatic_CNVTMessage::mutable_under_line() {
  set_has_under_line();
  // @@protoc_insertion_point(field_mutable:chaos_data.SymbolStatic.CNVTMessage.under_line)
  return under_line_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymbolStatic_CNVTMessage::release_under_line() {
  // @@protoc_insertion_point(field_release:chaos_data.SymbolStatic.CNVTMessage.under_line)
  clear_has_under_line();
  return under_line_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymbolStatic_CNVTMessage::set_allocated_under_line(::std::string* under_line) {
  if (under_line != NULL) {
    set_has_under_line();
  } else {
    clear_has_under_line();
  }
  under_line_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), under_line);
  // @@protoc_insertion_point(field_set_allocated:chaos_data.SymbolStatic.CNVTMessage.under_line)
}

// optional float accrued_int = 7;
inline bool SymbolStatic_CNVTMessage::has_accrued_int() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SymbolStatic_CNVTMessage::set_has_accrued_int() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SymbolStatic_CNVTMessage::clear_has_accrued_int() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SymbolStatic_CNVTMessage::clear_accrued_int() {
  accrued_int_ = 0;
  clear_has_accrued_int();
}
inline float SymbolStatic_CNVTMessage::accrued_int() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.CNVTMessage.accrued_int)
  return accrued_int_;
}
inline void SymbolStatic_CNVTMessage::set_accrued_int(float value) {
  set_has_accrued_int();
  accrued_int_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.CNVTMessage.accrued_int)
}

// -------------------------------------------------------------------

// SymbolStatic_FutureMessage

// optional uint32 last_day_OI = 1;
inline bool SymbolStatic_FutureMessage::has_last_day_oi() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolStatic_FutureMessage::set_has_last_day_oi() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolStatic_FutureMessage::clear_has_last_day_oi() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolStatic_FutureMessage::clear_last_day_oi() {
  last_day_oi_ = 0u;
  clear_has_last_day_oi();
}
inline ::google::protobuf::uint32 SymbolStatic_FutureMessage::last_day_oi() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.FutureMessage.last_day_OI)
  return last_day_oi_;
}
inline void SymbolStatic_FutureMessage::set_last_day_oi(::google::protobuf::uint32 value) {
  set_has_last_day_oi();
  last_day_oi_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.FutureMessage.last_day_OI)
}

// optional float last_settle_price = 2;
inline bool SymbolStatic_FutureMessage::has_last_settle_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolStatic_FutureMessage::set_has_last_settle_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolStatic_FutureMessage::clear_has_last_settle_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolStatic_FutureMessage::clear_last_settle_price() {
  last_settle_price_ = 0;
  clear_has_last_settle_price();
}
inline float SymbolStatic_FutureMessage::last_settle_price() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.FutureMessage.last_settle_price)
  return last_settle_price_;
}
inline void SymbolStatic_FutureMessage::set_last_settle_price(float value) {
  set_has_last_settle_price();
  last_settle_price_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.FutureMessage.last_settle_price)
}

// -------------------------------------------------------------------

// SymbolStatic_TruestMessage

// optional float asset = 3;
inline bool SymbolStatic_TruestMessage::has_asset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolStatic_TruestMessage::set_has_asset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolStatic_TruestMessage::clear_has_asset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolStatic_TruestMessage::clear_asset() {
  asset_ = 0;
  clear_has_asset();
}
inline float SymbolStatic_TruestMessage::asset() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.TruestMessage.asset)
  return asset_;
}
inline void SymbolStatic_TruestMessage::set_asset(float value) {
  set_has_asset();
  asset_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.TruestMessage.asset)
}

// optional uint32 asset_date = 4;
inline bool SymbolStatic_TruestMessage::has_asset_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolStatic_TruestMessage::set_has_asset_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolStatic_TruestMessage::clear_has_asset_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolStatic_TruestMessage::clear_asset_date() {
  asset_date_ = 0u;
  clear_has_asset_date();
}
inline ::google::protobuf::uint32 SymbolStatic_TruestMessage::asset_date() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.TruestMessage.asset_date)
  return asset_date_;
}
inline void SymbolStatic_TruestMessage::set_asset_date(::google::protobuf::uint32 value) {
  set_has_asset_date();
  asset_date_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.TruestMessage.asset_date)
}

// -------------------------------------------------------------------

// SymbolStatic_SpecMessage

// optional .chaos_data.SymbolStatic.EquityMessage equity = 1;
inline bool SymbolStatic_SpecMessage::has_equity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolStatic_SpecMessage::set_has_equity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolStatic_SpecMessage::clear_has_equity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolStatic_SpecMessage::clear_equity() {
  if (equity_ != NULL) equity_->::chaos_data::SymbolStatic_EquityMessage::Clear();
  clear_has_equity();
}
inline const ::chaos_data::SymbolStatic_EquityMessage& SymbolStatic_SpecMessage::equity() const {
  const ::chaos_data::SymbolStatic_EquityMessage* p = equity_;
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.SpecMessage.equity)
  return p != NULL ? *p : *reinterpret_cast<const ::chaos_data::SymbolStatic_EquityMessage*>(
      &::chaos_data::_SymbolStatic_EquityMessage_default_instance_);
}
inline ::chaos_data::SymbolStatic_EquityMessage* SymbolStatic_SpecMessage::mutable_equity() {
  set_has_equity();
  if (equity_ == NULL) {
    equity_ = new ::chaos_data::SymbolStatic_EquityMessage;
  }
  // @@protoc_insertion_point(field_mutable:chaos_data.SymbolStatic.SpecMessage.equity)
  return equity_;
}
inline ::chaos_data::SymbolStatic_EquityMessage* SymbolStatic_SpecMessage::release_equity() {
  // @@protoc_insertion_point(field_release:chaos_data.SymbolStatic.SpecMessage.equity)
  clear_has_equity();
  ::chaos_data::SymbolStatic_EquityMessage* temp = equity_;
  equity_ = NULL;
  return temp;
}
inline void SymbolStatic_SpecMessage::set_allocated_equity(::chaos_data::SymbolStatic_EquityMessage* equity) {
  delete equity_;
  equity_ = equity;
  if (equity) {
    set_has_equity();
  } else {
    clear_has_equity();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos_data.SymbolStatic.SpecMessage.equity)
}

// optional .chaos_data.SymbolStatic.FundMessage fund = 2;
inline bool SymbolStatic_SpecMessage::has_fund() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolStatic_SpecMessage::set_has_fund() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolStatic_SpecMessage::clear_has_fund() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolStatic_SpecMessage::clear_fund() {
  if (fund_ != NULL) fund_->::chaos_data::SymbolStatic_FundMessage::Clear();
  clear_has_fund();
}
inline const ::chaos_data::SymbolStatic_FundMessage& SymbolStatic_SpecMessage::fund() const {
  const ::chaos_data::SymbolStatic_FundMessage* p = fund_;
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.SpecMessage.fund)
  return p != NULL ? *p : *reinterpret_cast<const ::chaos_data::SymbolStatic_FundMessage*>(
      &::chaos_data::_SymbolStatic_FundMessage_default_instance_);
}
inline ::chaos_data::SymbolStatic_FundMessage* SymbolStatic_SpecMessage::mutable_fund() {
  set_has_fund();
  if (fund_ == NULL) {
    fund_ = new ::chaos_data::SymbolStatic_FundMessage;
  }
  // @@protoc_insertion_point(field_mutable:chaos_data.SymbolStatic.SpecMessage.fund)
  return fund_;
}
inline ::chaos_data::SymbolStatic_FundMessage* SymbolStatic_SpecMessage::release_fund() {
  // @@protoc_insertion_point(field_release:chaos_data.SymbolStatic.SpecMessage.fund)
  clear_has_fund();
  ::chaos_data::SymbolStatic_FundMessage* temp = fund_;
  fund_ = NULL;
  return temp;
}
inline void SymbolStatic_SpecMessage::set_allocated_fund(::chaos_data::SymbolStatic_FundMessage* fund) {
  delete fund_;
  fund_ = fund;
  if (fund) {
    set_has_fund();
  } else {
    clear_has_fund();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos_data.SymbolStatic.SpecMessage.fund)
}

// optional .chaos_data.SymbolStatic.WarranMessage warran = 3;
inline bool SymbolStatic_SpecMessage::has_warran() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolStatic_SpecMessage::set_has_warran() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolStatic_SpecMessage::clear_has_warran() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolStatic_SpecMessage::clear_warran() {
  if (warran_ != NULL) warran_->::chaos_data::SymbolStatic_WarranMessage::Clear();
  clear_has_warran();
}
inline const ::chaos_data::SymbolStatic_WarranMessage& SymbolStatic_SpecMessage::warran() const {
  const ::chaos_data::SymbolStatic_WarranMessage* p = warran_;
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.SpecMessage.warran)
  return p != NULL ? *p : *reinterpret_cast<const ::chaos_data::SymbolStatic_WarranMessage*>(
      &::chaos_data::_SymbolStatic_WarranMessage_default_instance_);
}
inline ::chaos_data::SymbolStatic_WarranMessage* SymbolStatic_SpecMessage::mutable_warran() {
  set_has_warran();
  if (warran_ == NULL) {
    warran_ = new ::chaos_data::SymbolStatic_WarranMessage;
  }
  // @@protoc_insertion_point(field_mutable:chaos_data.SymbolStatic.SpecMessage.warran)
  return warran_;
}
inline ::chaos_data::SymbolStatic_WarranMessage* SymbolStatic_SpecMessage::release_warran() {
  // @@protoc_insertion_point(field_release:chaos_data.SymbolStatic.SpecMessage.warran)
  clear_has_warran();
  ::chaos_data::SymbolStatic_WarranMessage* temp = warran_;
  warran_ = NULL;
  return temp;
}
inline void SymbolStatic_SpecMessage::set_allocated_warran(::chaos_data::SymbolStatic_WarranMessage* warran) {
  delete warran_;
  warran_ = warran;
  if (warran) {
    set_has_warran();
  } else {
    clear_has_warran();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos_data.SymbolStatic.SpecMessage.warran)
}

// optional .chaos_data.SymbolStatic.BoundMessage bound = 4;
inline bool SymbolStatic_SpecMessage::has_bound() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymbolStatic_SpecMessage::set_has_bound() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymbolStatic_SpecMessage::clear_has_bound() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymbolStatic_SpecMessage::clear_bound() {
  if (bound_ != NULL) bound_->::chaos_data::SymbolStatic_BoundMessage::Clear();
  clear_has_bound();
}
inline const ::chaos_data::SymbolStatic_BoundMessage& SymbolStatic_SpecMessage::bound() const {
  const ::chaos_data::SymbolStatic_BoundMessage* p = bound_;
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.SpecMessage.bound)
  return p != NULL ? *p : *reinterpret_cast<const ::chaos_data::SymbolStatic_BoundMessage*>(
      &::chaos_data::_SymbolStatic_BoundMessage_default_instance_);
}
inline ::chaos_data::SymbolStatic_BoundMessage* SymbolStatic_SpecMessage::mutable_bound() {
  set_has_bound();
  if (bound_ == NULL) {
    bound_ = new ::chaos_data::SymbolStatic_BoundMessage;
  }
  // @@protoc_insertion_point(field_mutable:chaos_data.SymbolStatic.SpecMessage.bound)
  return bound_;
}
inline ::chaos_data::SymbolStatic_BoundMessage* SymbolStatic_SpecMessage::release_bound() {
  // @@protoc_insertion_point(field_release:chaos_data.SymbolStatic.SpecMessage.bound)
  clear_has_bound();
  ::chaos_data::SymbolStatic_BoundMessage* temp = bound_;
  bound_ = NULL;
  return temp;
}
inline void SymbolStatic_SpecMessage::set_allocated_bound(::chaos_data::SymbolStatic_BoundMessage* bound) {
  delete bound_;
  bound_ = bound;
  if (bound) {
    set_has_bound();
  } else {
    clear_has_bound();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos_data.SymbolStatic.SpecMessage.bound)
}

// optional .chaos_data.SymbolStatic.CNVTMessage cnvt = 5;
inline bool SymbolStatic_SpecMessage::has_cnvt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SymbolStatic_SpecMessage::set_has_cnvt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SymbolStatic_SpecMessage::clear_has_cnvt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SymbolStatic_SpecMessage::clear_cnvt() {
  if (cnvt_ != NULL) cnvt_->::chaos_data::SymbolStatic_CNVTMessage::Clear();
  clear_has_cnvt();
}
inline const ::chaos_data::SymbolStatic_CNVTMessage& SymbolStatic_SpecMessage::cnvt() const {
  const ::chaos_data::SymbolStatic_CNVTMessage* p = cnvt_;
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.SpecMessage.cnvt)
  return p != NULL ? *p : *reinterpret_cast<const ::chaos_data::SymbolStatic_CNVTMessage*>(
      &::chaos_data::_SymbolStatic_CNVTMessage_default_instance_);
}
inline ::chaos_data::SymbolStatic_CNVTMessage* SymbolStatic_SpecMessage::mutable_cnvt() {
  set_has_cnvt();
  if (cnvt_ == NULL) {
    cnvt_ = new ::chaos_data::SymbolStatic_CNVTMessage;
  }
  // @@protoc_insertion_point(field_mutable:chaos_data.SymbolStatic.SpecMessage.cnvt)
  return cnvt_;
}
inline ::chaos_data::SymbolStatic_CNVTMessage* SymbolStatic_SpecMessage::release_cnvt() {
  // @@protoc_insertion_point(field_release:chaos_data.SymbolStatic.SpecMessage.cnvt)
  clear_has_cnvt();
  ::chaos_data::SymbolStatic_CNVTMessage* temp = cnvt_;
  cnvt_ = NULL;
  return temp;
}
inline void SymbolStatic_SpecMessage::set_allocated_cnvt(::chaos_data::SymbolStatic_CNVTMessage* cnvt) {
  delete cnvt_;
  cnvt_ = cnvt;
  if (cnvt) {
    set_has_cnvt();
  } else {
    clear_has_cnvt();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos_data.SymbolStatic.SpecMessage.cnvt)
}

// optional .chaos_data.SymbolStatic.FutureMessage future = 6;
inline bool SymbolStatic_SpecMessage::has_future() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SymbolStatic_SpecMessage::set_has_future() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SymbolStatic_SpecMessage::clear_has_future() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SymbolStatic_SpecMessage::clear_future() {
  if (future_ != NULL) future_->::chaos_data::SymbolStatic_FutureMessage::Clear();
  clear_has_future();
}
inline const ::chaos_data::SymbolStatic_FutureMessage& SymbolStatic_SpecMessage::future() const {
  const ::chaos_data::SymbolStatic_FutureMessage* p = future_;
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.SpecMessage.future)
  return p != NULL ? *p : *reinterpret_cast<const ::chaos_data::SymbolStatic_FutureMessage*>(
      &::chaos_data::_SymbolStatic_FutureMessage_default_instance_);
}
inline ::chaos_data::SymbolStatic_FutureMessage* SymbolStatic_SpecMessage::mutable_future() {
  set_has_future();
  if (future_ == NULL) {
    future_ = new ::chaos_data::SymbolStatic_FutureMessage;
  }
  // @@protoc_insertion_point(field_mutable:chaos_data.SymbolStatic.SpecMessage.future)
  return future_;
}
inline ::chaos_data::SymbolStatic_FutureMessage* SymbolStatic_SpecMessage::release_future() {
  // @@protoc_insertion_point(field_release:chaos_data.SymbolStatic.SpecMessage.future)
  clear_has_future();
  ::chaos_data::SymbolStatic_FutureMessage* temp = future_;
  future_ = NULL;
  return temp;
}
inline void SymbolStatic_SpecMessage::set_allocated_future(::chaos_data::SymbolStatic_FutureMessage* future) {
  delete future_;
  future_ = future;
  if (future) {
    set_has_future();
  } else {
    clear_has_future();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos_data.SymbolStatic.SpecMessage.future)
}

// optional .chaos_data.SymbolStatic.TruestMessage truest = 7;
inline bool SymbolStatic_SpecMessage::has_truest() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SymbolStatic_SpecMessage::set_has_truest() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SymbolStatic_SpecMessage::clear_has_truest() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SymbolStatic_SpecMessage::clear_truest() {
  if (truest_ != NULL) truest_->::chaos_data::SymbolStatic_TruestMessage::Clear();
  clear_has_truest();
}
inline const ::chaos_data::SymbolStatic_TruestMessage& SymbolStatic_SpecMessage::truest() const {
  const ::chaos_data::SymbolStatic_TruestMessage* p = truest_;
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.SpecMessage.truest)
  return p != NULL ? *p : *reinterpret_cast<const ::chaos_data::SymbolStatic_TruestMessage*>(
      &::chaos_data::_SymbolStatic_TruestMessage_default_instance_);
}
inline ::chaos_data::SymbolStatic_TruestMessage* SymbolStatic_SpecMessage::mutable_truest() {
  set_has_truest();
  if (truest_ == NULL) {
    truest_ = new ::chaos_data::SymbolStatic_TruestMessage;
  }
  // @@protoc_insertion_point(field_mutable:chaos_data.SymbolStatic.SpecMessage.truest)
  return truest_;
}
inline ::chaos_data::SymbolStatic_TruestMessage* SymbolStatic_SpecMessage::release_truest() {
  // @@protoc_insertion_point(field_release:chaos_data.SymbolStatic.SpecMessage.truest)
  clear_has_truest();
  ::chaos_data::SymbolStatic_TruestMessage* temp = truest_;
  truest_ = NULL;
  return temp;
}
inline void SymbolStatic_SpecMessage::set_allocated_truest(::chaos_data::SymbolStatic_TruestMessage* truest) {
  delete truest_;
  truest_ = truest;
  if (truest) {
    set_has_truest();
  } else {
    clear_has_truest();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos_data.SymbolStatic.SpecMessage.truest)
}

// -------------------------------------------------------------------

// SymbolStatic

// optional bytes symbol = 1;
inline bool SymbolStatic::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolStatic::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolStatic::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolStatic::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbol();
}
inline const ::std::string& SymbolStatic::symbol() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.symbol)
  return symbol_.GetNoArena();
}
inline void SymbolStatic::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.symbol)
}
#if LANG_CXX11
inline void SymbolStatic::set_symbol(::std::string&& value) {
  set_has_symbol();
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chaos_data.SymbolStatic.symbol)
}
#endif
inline void SymbolStatic::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos_data.SymbolStatic.symbol)
}
inline void SymbolStatic::set_symbol(const void* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos_data.SymbolStatic.symbol)
}
inline ::std::string* SymbolStatic::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:chaos_data.SymbolStatic.symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymbolStatic::release_symbol() {
  // @@protoc_insertion_point(field_release:chaos_data.SymbolStatic.symbol)
  clear_has_symbol();
  return symbol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymbolStatic::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:chaos_data.SymbolStatic.symbol)
}

// optional bytes name = 2;
inline bool SymbolStatic::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolStatic::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolStatic::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolStatic::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& SymbolStatic::name() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.name)
  return name_.GetNoArena();
}
inline void SymbolStatic::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.name)
}
#if LANG_CXX11
inline void SymbolStatic::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chaos_data.SymbolStatic.name)
}
#endif
inline void SymbolStatic::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chaos_data.SymbolStatic.name)
}
inline void SymbolStatic::set_name(const void* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chaos_data.SymbolStatic.name)
}
inline ::std::string* SymbolStatic::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:chaos_data.SymbolStatic.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SymbolStatic::release_name() {
  // @@protoc_insertion_point(field_release:chaos_data.SymbolStatic.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SymbolStatic::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:chaos_data.SymbolStatic.name)
}

// optional .chaos_data.SymbolStatic.SYMBOL_TYPE ctype = 3;
inline bool SymbolStatic::has_ctype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymbolStatic::set_has_ctype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymbolStatic::clear_has_ctype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymbolStatic::clear_ctype() {
  ctype_ = 0;
  clear_has_ctype();
}
inline ::chaos_data::SymbolStatic_SYMBOL_TYPE SymbolStatic::ctype() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.ctype)
  return static_cast< ::chaos_data::SymbolStatic_SYMBOL_TYPE >(ctype_);
}
inline void SymbolStatic::set_ctype(::chaos_data::SymbolStatic_SYMBOL_TYPE value) {
  assert(::chaos_data::SymbolStatic_SYMBOL_TYPE_IsValid(value));
  set_has_ctype();
  ctype_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.ctype)
}

// optional .chaos_data.SymbolStatic.SYMBOL_SUBTYPE csub_type = 4;
inline bool SymbolStatic::has_csub_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SymbolStatic::set_has_csub_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SymbolStatic::clear_has_csub_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SymbolStatic::clear_csub_type() {
  csub_type_ = 0;
  clear_has_csub_type();
}
inline ::chaos_data::SymbolStatic_SYMBOL_SUBTYPE SymbolStatic::csub_type() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.csub_type)
  return static_cast< ::chaos_data::SymbolStatic_SYMBOL_SUBTYPE >(csub_type_);
}
inline void SymbolStatic::set_csub_type(::chaos_data::SymbolStatic_SYMBOL_SUBTYPE value) {
  assert(::chaos_data::SymbolStatic_SYMBOL_SUBTYPE_IsValid(value));
  set_has_csub_type();
  csub_type_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.csub_type)
}

// optional uint32 price_digit = 5;
inline bool SymbolStatic::has_price_digit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SymbolStatic::set_has_price_digit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SymbolStatic::clear_has_price_digit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SymbolStatic::clear_price_digit() {
  price_digit_ = 0u;
  clear_has_price_digit();
}
inline ::google::protobuf::uint32 SymbolStatic::price_digit() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.price_digit)
  return price_digit_;
}
inline void SymbolStatic::set_price_digit(::google::protobuf::uint32 value) {
  set_has_price_digit();
  price_digit_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.price_digit)
}

// optional int32 vol_unit = 6;
inline bool SymbolStatic::has_vol_unit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SymbolStatic::set_has_vol_unit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SymbolStatic::clear_has_vol_unit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SymbolStatic::clear_vol_unit() {
  vol_unit_ = 0;
  clear_has_vol_unit();
}
inline ::google::protobuf::int32 SymbolStatic::vol_unit() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.vol_unit)
  return vol_unit_;
}
inline void SymbolStatic::set_vol_unit(::google::protobuf::int32 value) {
  set_has_vol_unit();
  vol_unit_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.vol_unit)
}

// optional int64 float_issued = 7;
inline bool SymbolStatic::has_float_issued() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SymbolStatic::set_has_float_issued() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SymbolStatic::clear_has_float_issued() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SymbolStatic::clear_float_issued() {
  float_issued_ = GOOGLE_LONGLONG(0);
  clear_has_float_issued();
}
inline ::google::protobuf::int64 SymbolStatic::float_issued() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.float_issued)
  return float_issued_;
}
inline void SymbolStatic::set_float_issued(::google::protobuf::int64 value) {
  set_has_float_issued();
  float_issued_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.float_issued)
}

// optional int64 total_issued = 8;
inline bool SymbolStatic::has_total_issued() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SymbolStatic::set_has_total_issued() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SymbolStatic::clear_has_total_issued() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SymbolStatic::clear_total_issued() {
  total_issued_ = GOOGLE_LONGLONG(0);
  clear_has_total_issued();
}
inline ::google::protobuf::int64 SymbolStatic::total_issued() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.total_issued)
  return total_issued_;
}
inline void SymbolStatic::set_total_issued(::google::protobuf::int64 value) {
  set_has_total_issued();
  total_issued_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.total_issued)
}

// optional uint32 last_close = 9;
inline bool SymbolStatic::has_last_close() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SymbolStatic::set_has_last_close() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SymbolStatic::clear_has_last_close() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SymbolStatic::clear_last_close() {
  last_close_ = 0u;
  clear_has_last_close();
}
inline ::google::protobuf::uint32 SymbolStatic::last_close() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.last_close)
  return last_close_;
}
inline void SymbolStatic::set_last_close(::google::protobuf::uint32 value) {
  set_has_last_close();
  last_close_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.last_close)
}

// optional uint32 adv_stop = 10;
inline bool SymbolStatic::has_adv_stop() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SymbolStatic::set_has_adv_stop() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SymbolStatic::clear_has_adv_stop() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SymbolStatic::clear_adv_stop() {
  adv_stop_ = 0u;
  clear_has_adv_stop();
}
inline ::google::protobuf::uint32 SymbolStatic::adv_stop() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.adv_stop)
  return adv_stop_;
}
inline void SymbolStatic::set_adv_stop(::google::protobuf::uint32 value) {
  set_has_adv_stop();
  adv_stop_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.adv_stop)
}

// optional uint32 dec_stop = 11;
inline bool SymbolStatic::has_dec_stop() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SymbolStatic::set_has_dec_stop() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SymbolStatic::clear_has_dec_stop() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SymbolStatic::clear_dec_stop() {
  dec_stop_ = 0u;
  clear_has_dec_stop();
}
inline ::google::protobuf::uint32 SymbolStatic::dec_stop() const {
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.dec_stop)
  return dec_stop_;
}
inline void SymbolStatic::set_dec_stop(::google::protobuf::uint32 value) {
  set_has_dec_stop();
  dec_stop_ = value;
  // @@protoc_insertion_point(field_set:chaos_data.SymbolStatic.dec_stop)
}

// optional .chaos_data.SymbolStatic.SpecMessage spec = 12;
inline bool SymbolStatic::has_spec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolStatic::set_has_spec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolStatic::clear_has_spec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolStatic::clear_spec() {
  if (spec_ != NULL) spec_->::chaos_data::SymbolStatic_SpecMessage::Clear();
  clear_has_spec();
}
inline const ::chaos_data::SymbolStatic_SpecMessage& SymbolStatic::spec() const {
  const ::chaos_data::SymbolStatic_SpecMessage* p = spec_;
  // @@protoc_insertion_point(field_get:chaos_data.SymbolStatic.spec)
  return p != NULL ? *p : *reinterpret_cast<const ::chaos_data::SymbolStatic_SpecMessage*>(
      &::chaos_data::_SymbolStatic_SpecMessage_default_instance_);
}
inline ::chaos_data::SymbolStatic_SpecMessage* SymbolStatic::mutable_spec() {
  set_has_spec();
  if (spec_ == NULL) {
    spec_ = new ::chaos_data::SymbolStatic_SpecMessage;
  }
  // @@protoc_insertion_point(field_mutable:chaos_data.SymbolStatic.spec)
  return spec_;
}
inline ::chaos_data::SymbolStatic_SpecMessage* SymbolStatic::release_spec() {
  // @@protoc_insertion_point(field_release:chaos_data.SymbolStatic.spec)
  clear_has_spec();
  ::chaos_data::SymbolStatic_SpecMessage* temp = spec_;
  spec_ = NULL;
  return temp;
}
inline void SymbolStatic::set_allocated_spec(::chaos_data::SymbolStatic_SpecMessage* spec) {
  delete spec_;
  spec_ = spec;
  if (spec) {
    set_has_spec();
  } else {
    clear_has_spec();
  }
  // @@protoc_insertion_point(field_set_allocated:chaos_data.SymbolStatic.spec)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace chaos_data

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::chaos_data::SymbolStatic_SYMBOL_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chaos_data::SymbolStatic_SYMBOL_TYPE>() {
  return ::chaos_data::SymbolStatic_SYMBOL_TYPE_descriptor();
}
template <> struct is_proto_enum< ::chaos_data::SymbolStatic_SYMBOL_SUBTYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chaos_data::SymbolStatic_SYMBOL_SUBTYPE>() {
  return ::chaos_data::SymbolStatic_SYMBOL_SUBTYPE_descriptor();
}
template <> struct is_proto_enum< ::chaos_data::SymbolStatic_SYMBOL_SP> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chaos_data::SymbolStatic_SYMBOL_SP>() {
  return ::chaos_data::SymbolStatic_SYMBOL_SP_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_symbol_5fstatic_2eproto__INCLUDED
